Rxjava+Retrofit
aidl
service笔记

 dragger2:    https://www.jianshu.com/p/22c397354997
 bitmap:      http://ms.csdn.net/geek/69041?from=timeline

 Android Studio 配置 toString( ) 模板，定制 JSON 格式字串的步骤
 http://blog.csdn.net/NongJushi/article/details/75500867

service:
http://blog.csdn.net/luoyanglizi/article/details/51586437

1.与其他组件联系方式：startService()、bindService()
    “其他组件”不包括Broadcast receiver，其无法直接启动或绑定service。
    功能：
    1.启动service的方式：s/b_在其他组件中，调用方法后，服务即处于启动状态。

    区别：
    1.停止service的方式
        s_service调用stopSelf()，或者其他组件调用stopService()后，service 停止运行。
        b_所有与service绑定的组件被销毁，或者他们都调用了unbindService()后，service 停止运行。
    2.service与启动它的组件之间的通信方式
        s_没有提供默认的通信方式，启动service后该service就处于独立运行状态.
        b_可以通过 ServiceConnection进行通信，组件可以与service进行交互、
            发送请求、获取结果，甚至是利用IPC跨进程执行这些操作
    3.service的生命周期
        s_一旦启动，service即可在后台无限期运行，即使启动service的组件已被销毁也不受其影响，
            直到其被停止
        b_当所有与其绑定的组件都取消绑定(可能是组件被销毁也有可能是其调用了unbindService()方法)后，
            service将停止

2.生命周期方法：
    1. int onStartCommand(Intent intent, int flags, int startId)
        service主要的操作，
        当其他组件通过startService()方法启动service时，此方法将会被调用。


    2. IBinder onBind(Intent intent)
        当其他组件通过bindService()方法与service相绑定之后，此方法将会被调用；
        重写它的时候必须返回一个IBinder对象，用来支撑其他组件与service之间的通信；
        如果你不想让这个service被其他组件所绑定，可以通过在这个方法返回一个null值来实现。

3.Manifests属性：
    <service
        android:enabled=["true" | "false"]
        android:exported=["true" | "false"]
        android:icon="drawable resource"
        android:isolatedProcess=["true" | "false"]
        android:label="string resource"
        android:name="string" //唯一必填
        android:permission="string"
        android:process="string" >
    </service>

    1.enabled:是否可以被系统实例化
    2.explorted:
        true_其他应用的组件可以调用此service,并可以互动。
        false_只有与service统一应用或相同userId的应用可以开启或绑定。
        默认值取决于service是否有intent filters,
            若没有，默认false,只有指定了service的准确类名才能调用，即只能应用内使用。
            若有，默认true,考虑了外界使用的情况。
    3.label:
        显示给用户的这个service的名字。如果不设置，将会默认使用<application>的label属性。
    4.isolatedProcess:
        默认为false，
        如果设置为true，这个service将运行在一个从系统中其他部分分离出来的特殊进程中，
        我们只能通过Service API来与它进行交流。
    5.process:
        service运行的进程的name。默认启动的service是运行在主进程中的。

4.使用场景：
        1.startService(),其他组件通过调用此方法即可启动特定的service，并导致onStartCommand()方法调用，
    通过intent传值，比如此时某个Activity要将一些数据存入数据库中，我就可以通过intent把数据传入service，
    然后让service去进行连接数据库，存储数据等操作，而此时用户可以执行其他的任何操作
    ——甚至包括销毁那个Activity——这并不会影响service存储数据这件事。
        当一个service通过这种方式启动之后，它的生命周期就已经不受启动它的组件影响了，它可以在后台无限期的
    运行下去，只要service自身没有调用stopSelf()并且其他的组件没有调用针对它的stopService()。
        默认service将工作于应用的主线程，而这将会降低所有正在运行的Activity的性能。如果确定了使用这种方式
    启动service并且不希望这个service被绑定的话，更好的做法是继承IntentService：
    1.创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent
    2.创建工作队列，用于将一个 Intent 逐一传递给 onHandleIntent() 实现，这样的话就永远不必担心多线程问题了
    3.在处理完所有启动请求后停止服务，从此妈妈再也不用担心我忘记调用 stopSelf() 了
    4.提供 onBind() 的默认实现（返回 null）
    5.提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现

    在super()中对工作线程、工作队列初始化以及销毁等操作。如果让service同时处理多个请求，只能继承service.

        2.bindService(),可以完成比startService()更多的事情，比如其他组件可向其发送请求，接受来自它的响应，
    甚至通过它来进行IPC等等。我们通常将绑定它的组件成为客户端，而称它为服务器。
        如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，
    它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式：
        1.继承Binder类，
        2.使用Messenger类，
        3.使用AIDL。




